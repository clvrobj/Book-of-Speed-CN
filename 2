速度之书

Page2.0的一生

在它孩提时，网络是一个文档检索(?)系统，最初就是一个提供一些互相链接的静态页面。你从一个链接或是通过在浏览器的地址栏写下地址就可以从服务器取回一个新页面并显示出来。不过在Web2.0或后Web2.0的世界中用户体验可大不一样。通过附加的Javascript、CSS和Ajax(XMLHttpRequest)那些页面更像是应用程序(?)，而不再是静态的文档。

这章描画了人类生命与当代(?)的将被我们称作Page2.0的网络页面(或网络引用)的一条平行线(?)，在考虑了Page2.0的一生的各个阶段后，这章从大体上概括了每一阶段的性能优化的可能。之后的章节会更深入的挖掘如何应用这些优化并以速度为目标创建网络应用。

一辈子

让我们看看在图2.1中展示的Page2.0这一生的不同阶段。在时间线上可以看到一个页面一生的一系列关键时刻同时是如何对应到人的一生的。

请求(Request)
一切始于页面请求。某人输入了URL或者点击了链接。这一刻页面产生了意识(?)。我们将在第三章详细的观察请求是什么与如何工作(?)。

生成HTML文档
之后服务器就就"怀上了"页面。这一阶段以前很简单只(?)包含了服务器软件在服务器硬盘上搜寻被请求的静态页面(HTML文件)并且读取文件内容。但是现在事情变复杂了，大多数网站在服务器端使用编程语言比如PHP，Ruby，Python，Perl等来动态的组合出一个结果文档(?)。

服务器端程序(一般称作服务器端脚本)先是从别处抓取数据，通常是从数据库或者从别的服务器通过网络服务获取。然后把这些数据组合(?)拼凑在一起生成一段HTML代码形式的字符串，这就是新的动态生成文档的方式。

这本书中我们将不会花多少笔墨(?)在优化这一部分上，因为之后我们会看到，通常这不是花费时间最多的地方。

响应(Response)

如果幸运地中途没有出现问题(?)比如退出(?)或者404找不到页面错误，孕育就完成了，HTML文档就以所谓HTTP响应的方式被发送到了浏览器。

Page 2.0就正式的出生啦。

瀑布

然后就到了瀑布阶段，这一阶段浏览器下载如图像、脚本、样式等页面必需的其他组件，在HTML文档所引用的所有组件都倍下载完成后，这一阶段将以onload事件被浏览器触发作为结束。这一阶段大致上可以对应到人生命的童年时代，最终将毕业成为Page女士(TBB)。对于速度优化来说，瀑布阶段是最重要的一个阶段。这本书的主要部分，从第三章开始，将主要优化这一阶段。

寻找自我(?)

就在onload被触发后就到了"寻找自我"(?)阶段，这一阶段年轻的Page女士仍然在寻找她的真我与身份。从技术角度来说，这一阶段是JavaScript脚本进入角色并且开始实施一些初始化工作，比如说绑定事件处理方法到DOM元素上，逐渐增强(?)，也可能通过Ajax调用获取一些组件或额外的数据。

页面最终就稳定下来了。状态栏不再显示正在下载状态的网址，浏览器指示符(?)不再转了，光标不再显示忙碌状态并且用户获得完整的交互体验。可以这么说:这个年轻的成年人(?)西欧和西藏背包旅行归来并且做好成家准备，找到一个稳定的工作还拥有了一个烤肉架(?)。

用户交互

人生在继续(?)，用户与页面进行交互。一些页面完全是静态的没有事件响应，比如一篇新闻或者一篇博客，对也页面来说，然而偶尔轮换的广告更能令人兴奋(?)。还有其他的频繁上传下载数据的网站应用(想想网页版的邮箱)，总是在获取更多数据，更新和自我改进，总是在行动。

下一个请求

早晚会有另一请求来终止这一切。用户离开了页面，开始另一个请求，浏览器触发了onunload事件之后我们的Page就被迫的休息了。

什么时候Page就完成了?

onload事件可以代表页面已经准备好了，不过事情总是没那么简单。就像没办法界定一个人什么时候成熟一样。而"用户加载(?)"的时机无法固定，在onload事件之前或之后都有可能。取决于不同页面或应用的类型也取决于使用者。

图2.2 "用户加载"页面与页面不同，用户与用户也不同

当一个文章页面的标题和内容准备好后就可以认为这个页面已经准备好了。用户可以阅读即与页面交互，同时图片和广告仍然在下载中。另外一些情况加载可能相对更迅速，不过页面的实质内容仍然在下载页面离可以正常使用还差得远，除了了一个启动屏幕之外没任何东西(可能会展示一个"正在加载..."的字样伴随着一个转轮动画)同时实际内容还得等着没出来。

用户的习惯不同，一些用户会停止所有操作来等待页面加载完成。而其他用户则几乎页面一有东西显示出来就立即开始滚动页面，这也说明了为何页面的顶部通常放置一个横条广告或者是网站标志和导航(?)。

"用户加载"这事完全取决于你的页面和用户类型。由于缺少一个更好的定义，性能统计时一般将页面的onload事件或者DOMContentLoaded(?)作为对用户加载时机的一个比较好的估计。

路在继续

现在我们已经搞清了一个页面最重要的生命时间，我们来在一个高层次探索:我们能对每个阶段能做什么优化。

可能对于许多页面列为首位而且最重要的优化就是瀑布阶段，因为通常这是最花时间的阶段。然而你也可以对页面的其他任何阶段进行优化。不过重要的是要搞清瓶颈所在，然后列出优先级并着重优化能获得最大收益的部分。

下面是对每一阶段主要优化活动的总结。如果有些看不大明白也没关系，本书之后会一一详细阐明。

对请求请求阶段进行优化，包括通过对静态页面组件比如图片减少cookie数量甚至不带cookie请求以减少请求大小(?)。优化瀑布阶段可以分为以下几类:
减少页面组件: 很明显页面包含的内容越少你的瀑布阶段耗时越短。第三章会介绍减少HTTP请求的数量，融合(?)组件，使用CSS sprites，使用数据URI(?)和MHTML，使用缓存和"永不过期"策略提高重复来访，减少重复，near(?)重复并使用老式的文本样式的404无法找到错误页面。为减少组件数量你可以将不需要立即显示的组件延后到下一个生命阶段再加载-在onload之后(这项技术被称为"lazy-loading"懒惰加载)。

更小的组件: 减少或融合组件之后，剩下的组件应该尽可能地更小。可以使用压缩，minification(?)，零尺寸204组件(这些技术会在第四章进行描述)和优化图像。

Move out of the way(?): 再瀑布阶段一些组件不是并行加载的。并行加载组件很好，因为组件同时下载可以使这一阶段更早结束，第六章将讨论无阻断的Javascript和CSS，还有减少DNS查询跳转次数。

如果瀑布阶段能提早开始(?启动)也就有可能提早结束。第九章描述了使用flushing and HTTP chinked encoding(?)来开始瀑布阶段，甚至早于页面的生成。(这种方法就好像你已经知道肚子里的是个女孩，你就可以提前准备粉颜色的小孩用具了)

优化onload之后的阶段: 这里也是可以做点什么的。比如你可以在DOMCntentLoaded时间触发之后就之后开始一些Javascript脚本初始化工作，而不必等到onload事件触发。

交互阶段(成年之后)的优化包括了优化CSS和JavaScript的性能让使用更流畅，更舒服，UI更快响应(第七、八章)。

对于生命的最后，也可以做点什么的。又老又累的老页面可以留下一些有价值的遗产(可供预加载的组件)给后代，他们将可以用来提高速度。

让我们开始吧!

这一章描述了现代Page 2.0医生的主要部分和阶段，同时提供了每一阶段提高性能的路线图。

现在让我们进入细节吧(?)。